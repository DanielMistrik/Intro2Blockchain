
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>2.1. Chapter &#8212; An Introduction to the Blockchain</title>
    
  <link href="../../_static/css/theme.css" rel="stylesheet">
  <link href="../../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/togglebutton.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
    <script async="async" src="https://unpkg.com/thebe@0.5.1/lib/index.js"></script>
    <script>
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <link rel="shortcut icon" href="../../_static/logo.png"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="2.2. Summary" href="summary.html" />
    <link rel="prev" title="2. Cryptography" href="title.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../../_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">An Introduction to the Blockchain</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../intro.html">
   Introduction to the Blockchain
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Preface
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../preface/background.html">
   Background
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Basics
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../baad/title.html">
   1. Blockchain as a Data Structure
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../baad/text.html">
     1.1. Chapter
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../baad/summary.html">
     1.2. Summary
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../baad/questions.html">
     1.3. Exercises
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../baad/citations.html">
     1.4. Citations
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="title.html">
   2. Cryptography
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     2.1. Chapter
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="summary.html">
     2.2. Summary
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="questions.html">
     2.3. Exercises
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="citations.html">
     2.4. Citations
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../networks/title.html">
   3. Networks
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../networks/text.html">
     3.1. Chapter
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../networks/summary.html">
     3.2. Summary
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../networks/questions.html">
     3.3. Exercises
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../networks/citations.html">
     3.4. Citations
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Implementation
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../bitcoin/title.html">
   4. Bitcoin
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
  <label for="toctree-checkbox-4">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../bitcoin/text.html">
     4.1. Chapter
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../bitcoin/summary.html">
     4.2. Summary
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../bitcoin/questions.html">
     4.3. Exercises
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../bitcoin/citations.html">
     4.4. Citations
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../ethereum/title.html">
   5. Ethereum
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
  <label for="toctree-checkbox-5">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../ethereum/text.html">
     5.1. Chapter
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../ethereum/summary.html">
     5.2. Summary
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../ethereum/questions.html">
     5.3. Exercises
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../ethereum/citations.html">
     5.4. Citations
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../vulnerabilities/title.html">
   6. Vulnerabilities
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/>
  <label for="toctree-checkbox-6">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../vulnerabilities/text.html">
     6.1. Chapter
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../vulnerabilities/summary.html">
     6.2. Summary
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../vulnerabilities/questions.html">
     6.3. Exercises
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../vulnerabilities/citations.html">
     6.4. Citations
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  On top of Blockchain
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../layer2/title.html">
   7. Layer 2
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/>
  <label for="toctree-checkbox-7">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../layer2/text.html">
     7.1. Chapter
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../layer2/summary.html">
     7.2. Summary
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../layer2/questions.html">
     7.3. Exercises
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../layer2/citations.html">
     7.4. Citations
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../DeFi/title.html">
   8. DeFi
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/>
  <label for="toctree-checkbox-8">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../DeFi/text.html">
     8.1. Chapter
    </a>
   </li>
  </ul>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../../_sources/chapters/crypto/text.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/DanielMistrik/Intro2Blockchain"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/DanielMistrik/Intro2Blockchain/issues/new?title=Issue%20on%20page%20%2Fchapters/crypto/text.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#cryptography-basics">
   2.1.1. Cryptography Basics
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#number-systems">
     2.1.1.1. Number Systems
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#bitwise-operations">
     2.1.1.2. Bitwise Operations
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#hashing">
   2.1.2. Hashing
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#how-it-works">
     2.1.2.1. How it Works
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#cracking-hashes">
     2.1.2.2. Cracking Hashes
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#merkle-trees">
     2.1.2.3. Merkle Trees
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#block-validation-in-pow">
     2.1.2.4. Block Validation in PoW
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#public-private-cryptography">
   2.1.3. Public-Private Cryptography
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#digital-signature">
     2.1.3.1. Digital Signature
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#ppc-implementations">
     2.1.3.2. PPC Implementations
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#rsa">
       2.1.3.2.1. RSA
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#ecdsa">
       2.1.3.2.2. ECDSA
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#ecdsa-v-rsa">
       2.1.3.2.3. ECDSA v RSA
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#cryptography-in-action">
   2.1.4. Cryptography in Action
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#cryptography-in-the-blockchain">
     2.1.4.1. Cryptography in the Blockchain
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#back-to-byzantium">
     2.1.4.2. Back to Byzantium
    </a>
   </li>
  </ul>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="tex2jax_ignore mathjax_ignore section" id="chapter">
<h1><span class="section-number">2.1. </span>Chapter<a class="headerlink" href="#chapter" title="Permalink to this headline">¶</a></h1>
<p><a class="reference external" href="https://techterms.com/definition/cryptography">Cryptography</a> is the study of securing
information derived from complex mathematics. This is a very general definition because
cryptography is a very large topic that goes beyond just CS. Cryptography is a fascinating
field that lies in the cross paths of computer science and mathematics and is the
subject of active research. For those at Cornell who are interested in exploring
more of cryptography we recommend <a class="reference external" href="https://cornellcswiki.gitlab.io/classes/CS4830.html">CS4830</a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When we talk about cryptography in blockchain we are mainly concerned with
cryptography’s ability to secure and validate data like blocks and the data they store.</p>
</div>
<p>Blockchain depends on two primary cryptographic devices:</p>
<ul class="simple">
<li><p><strong>Hashing</strong> - Used to act as a signature of blocks and the
backbone of merkle trees and validate blocks in <em>Proof-of-Work</em> consensus.</p></li>
<li><p><strong>Digital Signature</strong> - Used to verify individual participants signing off on a piece
of data and so validate data in blocks.</p></li>
</ul>
<p>The two devices work in tandem and give blockchain trust in a trustless environment.
In the previous chapter we left this statement without explaining the
seeming paradox of a trusted system composed of untrusted nodes. Both of the cryptographic devices
above are rooted in theoretical math and so can be proven correct and valid. Not even
dishonest participants can forge them which means their use guarantees trust and validity.</p>
<div class="section" id="cryptography-basics">
<h2><span class="section-number">2.1.1. </span>Cryptography Basics<a class="headerlink" href="#cryptography-basics" title="Permalink to this headline">¶</a></h2>
<p>Before we get into the intricacies of cryptography we need to understand some basic
ideas that cryptography uses. First we need to understand the ‘language’ cryptography
operates in, <em>number systems</em>, and how it manipulates this language, <em>bitwise operations</em>.</p>
<div class="section" id="number-systems">
<h3><span class="section-number">2.1.1.1. </span>Number Systems<a class="headerlink" href="#number-systems" title="Permalink to this headline">¶</a></h3>
<p>As you may or may not know computers don’t understand human languages, they understand
binary. Luckily thanks to countless very bright programmers and engineers who
built a <em>layer of abstraction</em> we can use computers without knowing binary. But
cryptography works at the very ‘core’ of computers and so uses languages they understand.</p>
<p><em>Binary</em> is at the end of the day what computers really understand, it is the
sequential stream of 1’s and 0’s that you see in many movies and images. While it is
now closely associated with computers it is first and foremost a <em>number system</em>.
When binary is used in computers each numeral (1 or 0) is called a <em>bit</em> and 8 bits
is a <em>byte</em>. <em>Bytes</em> form the basis of every piece of computer data.</p>
<p><em>Number Systems</em> are how we represent numbers. You are most likely accustomed to
the base-10(<em>decimal</em>) number system that has 10 numerals. We use it because it is the most
intuitive as we have 10 fingers, but it is not the only number system out there.
The <a class="reference external" href="https://www.thoughtco.com/why-we-still-use-babylonian-mathematics-116679">Babylonians used a base-60 number system</a>
and cryptography primarily uses <em>binary</em> and <em>hexadecimal</em>.</p>
<p>We use <em>binary</em>, or base-2 composed of 2 numerals 1 and 0, because it is what basic
building blocks of computers, <em>logic gates</em>, can work with.</p>
<p>We use <em>hexadecimal</em>,or base-16 composed of the standard 10 numerals and the 6 letters
from ‘a’ to ‘f’, because working with binary is incredibly complicated. Hexadecimal
is more <em>terse</em> and is used frequently in  <em>lower-level programming</em>, programming
that works in languages computers understand more than languages like English.</p>
<p>We will see hexadecimal re-appear throughout the course as we examine the basic building
blocks of blockchain implementations like Ethereum.</p>
<div class="tip admonition">
<p class="admonition-title">Example</p>
<p>Below is the number 42 represented in three different number systems:</p>
<ul class="simple">
<li><p><strong>Binary</strong>: 101010</p></li>
<li><p><strong>Decimal</strong>: 42</p></li>
<li><p><strong>Hexadecimal</strong>: 2A</p></li>
</ul>
</div>
</div>
<div class="section" id="bitwise-operations">
<h3><span class="section-number">2.1.1.2. </span>Bitwise Operations<a class="headerlink" href="#bitwise-operations" title="Permalink to this headline">¶</a></h3>
<p>As with all languages, we need a way to manipulate them. Bitwise operations are
operators on binary and imitate what <em>logic gates</em>, the basic building blocks of
computers, do. While their use-case isn’t immediately clear they are an integral part of
computer science with <a class="reference external" href="https://stackoverflow.com/questions/2096916/real-world-use-cases-of-bitwise-operators">a wide range of applications</a>
including cryptography.</p>
<p>Bitwise operations work by taking two binary <em>streams</em>, sequences of 1’s and 0’s, of
equal length and produce a new binary stream from them. They do this by analyzing
the bytes at every individual position and, depending on what operator,
produce either a 1 or 0.</p>
<p>Bitwise Operators are not an easy concept, and we do not expect you to understand
them fully. We only want to make sure you have a rough idea of how they work so when
we explain processes like hashing you will be able to understand it a little more
deeply.</p>
<div class="tip admonition">
<p class="admonition-title">Example</p>
<p>There are many bitwise operators, but we will be looking at OR and AND.</p>
<p><strong>OR</strong> - Produces a 1 if either or both input bits are 1 and 0 otherwise. If we had
input streams <em>1010</em> and <em>1100</em> the OR operator would output <em>1110</em>. This is because
when the operator looks at the first bit of both streams it sees it has two 1’s and
so produces another 1, the second bit in the streams is a 1 and 0 which produces a 1,
the same goes for the third bit but for the fourth and final bit they are both 0 so the
OR operator produces a 0.</p>
<p><strong>AND</strong> - Produces a 1 if both input bits are 1 and 0 otherwise. Therefore, if we
had input streams <em>1010</em> and <em>1100</em> the AND operator would output <em>1000</em>.</p>
</div>
</div>
</div>
<div class="section" id="hashing">
<h2><span class="section-number">2.1.2. </span>Hashing<a class="headerlink" href="#hashing" title="Permalink to this headline">¶</a></h2>
<p>A formal definition of hashing is a <em>hash function</em> which takes an input of arbitrary
size and produces an output value, a number, of fixed-size, the <em>hash digest</em>. Hash functions
are very useful. They appear in data structures, through Hash tables &amp; Merkle
trees, password verification and ofcourse data signatures.</p>
<p>There are alot of implementations of hash functions but good ones should share the
four following characteristics:</p>
<ul class="simple">
<li><p><strong>Deterministic</strong> - A given input will <em>always</em> produce the same output for the same
hash function implementation.</p></li>
<li><p><strong>One-Way Function</strong> - You can quickly and easily take an input and calculate the
output, the <em>hash digest</em>, but you cannot take the output, the <em>hash digest</em>, and quickly
get the input. You could say the hash function is not <em>invertible</em>.</p></li>
<li><p><strong>Collision Resistant</strong> - The number of inputs that share the same output, known
as a <em>collision</em>, should be as small as possible. Ideally one input maps to one output but as
the output is fixed-size and input can be anything even the best hash functions are
bound to have collisions.</p></li>
<li><p><strong>Avalanche-Effect</strong> - Changing the input even slightly has a profound, and unpredictable, effect
on the output.</p></li>
</ul>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>The four properties of good hash functions are incredibly important. They are the
properties that make hash functions so useful, so they are definitely something
to remember.</p>
</div>
<div class="section" id="how-it-works">
<h3><span class="section-number">2.1.2.1. </span>How it Works<a class="headerlink" href="#how-it-works" title="Permalink to this headline">¶</a></h3>
<p>Hash functions typically work with binary but the hash digest is often represented as
a hexadecimal due to terseness. Implementations always try to provide the four
properties of good hash functions but how they achieve this varies greatly.
We will be looking at SHA-256 because it is the most widely used and
is also Bitcoin’s hash function.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Alot of CS textbooks give examples of very simple hash functions (i.e. converting data
to a number and the output is that number times two). We disagree with this approach.
These kinds of simple hash functions don’t have the four good hash function properties and
as such are never used in the real-world. This makes teaching them redundant. We will be showing
you SHA-256 which is incredibly difficult but incredibly useful. We do not expect you to understand it.
We are putting it in this textbook merely, so you are <em>aware</em> of its inner-workings, and you can rest
assured that for 99.5% of blockchain projects you will not have to understand it fully.</p>
</div>
<p>From a simplified perspective, SHA-256 works as follows:</p>
<ol class="simple">
<li><p>Convert the input data into binary.</p></li>
<li><p>‘Pad’ the data, add 0’s to the end, and add its original length in binary to it so its
final length is divisible by 512, that is its length is divisible by 512.</p></li>
<li><p>Divide the entire binary sequence into 512 bit long ‘chunks’.</p></li>
<li><p>Taking each chunk one-by-one first divide it further into 16 32-bit ‘windows’ and then
add another 48 32-bit ‘windows’ initialized to 0.</p></li>
<li><p>For the 16 non-empty windows run some logic and the XOR bitwise operator on them and
put the results in the 48 empty windows.</p></li>
<li><p>Starting with 8 pre-defined hash values modify them by compressing the 64 words into them
through XOR and bit-logic. These 8 hash values will only have pre-defined values when
the windows from the first ‘chunk’ are compressed into them. After that the results of the
compression are changed. If any of the 8 hash values are greater than 2^32 the modulo operator is applied,
so they are always smaller than 2^32.</p></li>
<li><p>After we iterated over all the chunks unite the 8 resulting hash functions, convert
them to hexadecimal, and you have your hash digest.</p></li>
</ol>
<p>We warned you. This is not simple in the slightest and why these steps are the way they
are is far beyond the scope of this textbook. If you want one thing to take away from
all of this then know that hash functions use bitwise operations, logic and modulo to guarantee
the four good hash function properties.</p>
<p><strong>SHA-256</strong> is the hash function we described above, and it is part of the SHA-2 family
created by NIST in 2001. It has a 256-bit hash digest. Its notable use-case in Blockchain
is Bitcoin.</p>
<p><strong>Keccak-256</strong> is Ethereum’s hash function. It was the <em>original</em> version of NIST’s
SHA3 before it was edited by NIST in 2013. These edits caused some concerns that
NIST was engineering a <em>backdoor</em> in SHA3 so the creators of Ethereum decided to use
the raw unedited SHA3 called Keccak-256. Like SHA-256 it has a 256-bit hash digest.</p>
</div>
<div class="section" id="cracking-hashes">
<h3><span class="section-number">2.1.2.2. </span>Cracking Hashes<a class="headerlink" href="#cracking-hashes" title="Permalink to this headline">¶</a></h3>
<p>There are two primary ways to crack a hash function:
finding the input to the hash function from a hash digest, or finding hash <em>collisions</em>.</p>
<p><em>Collisions</em> are when two different inputs have the same output and while good hash
functions should not have alot them advancements in computer processing have made
once good hash functions, like SHA-1, susceptible to <em>collision attacks</em>.</p>
<p><em>Collision Attacks</em> are when you take any piece of data and <em>salt</em> it with additional
data so that it has a desired hash digest. This attack can therefore misuse services
that, for security reasons, only compare hash digests and not the actual input (i.e.
password verification). SHA-1’s algorithm has been cracked to the point that
you can find a hash collision in 2^62 calculations. In comparison, for the yet
uncracked SHA-256 you would have to do 2^256 calculations to find a collision.</p>
<p><em>Brute-Force Attacks</em> are attacks that try to <em>reverse</em> a hash function and this is
much more difficult, to the point of impossibility, than collision attacks. This is
because complex hashing functions cannot be <em>reversed</em> and changing their input gives an unpredictable
output so the only way you can find the input
for a given output is to try all possible inputs until you get your desired output. For SHA-256
this would take roughly 2^256 computations.For reference this would take the whole worlds computing
power more time than the predicted lifespan of the universe. Note, because of
collisions even if you find an input that translates to your desired output you can
never be sure it is the input you want.</p>
</div>
<div class="section" id="merkle-trees">
<h3><span class="section-number">2.1.2.3. </span>Merkle Trees<a class="headerlink" href="#merkle-trees" title="Permalink to this headline">¶</a></h3>
<p>Now that we understand hashing we can cover merkle trees in more depth. Because of
how rare collisions in good hash functions are when we compute the merkle root of
any data set we can be confident that this root is unique. This makes merkle roots
almost impossible to impersonate making them immutable once their root is in the block
header. This is because it is practically impossible for an attacker to get the same root
hash for a different merkle tree than the one intended so no node in the blockchain
network could be tricked into accepting wrong/malicious data.</p>
<div class="tip admonition">
<p class="admonition-title">Example</p>
<p>Lets create a merkle tree with the following pieces of data: the numbers 1,2,3 and 4.
For this example we will be using the <a class="reference external" href="http://www.unit-conversion.info/texttools/adler-32/#data">Adler32</a> hashing algorithm.</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p><img alt="s1" src="../../_images/mt_1.png" /></p></th>
<th class="head"><p><img alt="s2" src="../../_images/mt_2.png" /></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><em>Step 1: Arrange tha values as leaves</em></p></td>
<td><p><em>Step 2: Calculate hash digests of values</em></p></td>
</tr>
<tr class="row-odd"><td><p><img alt="s3" src="../../_images/mt_3.png" /></p></td>
<td><p><img alt="s4" src="../../_images/mt_4.png" /></p></td>
</tr>
<tr class="row-even"><td><p><em>Step 3: Combine hashes and calculate their hash digest as the value of the parent node</em></p></td>
<td><p><em>Step 4: Repeat step 3 until you have the merkle root, pictured green.</em></p></td>
</tr>
</tbody>
</table>
</div>
<p>Merkle trees are secure and space efficient because just like a hash function can
represent data of any size, a merkle root can represent a merkle tree of any size.
This is particularly important in the space sensitive blockchain were every participant
has to store the whole blockchain.</p>
</div>
<div class="section" id="block-validation-in-pow">
<h3><span class="section-number">2.1.2.4. </span>Block Validation in PoW<a class="headerlink" href="#block-validation-in-pow" title="Permalink to this headline">¶</a></h3>
<p>In the last chapter we briefly covered block validation and consensus
algorithms.
Consensus algorithms try to achieve two goals:</p>
<ul class="simple">
<li><p>Limit the number of valid blocks produced in a
time interval. This is to guarantee that every node gets the newest block in time to
synchronize before the next block is produced.</p></li>
<li><p>Try to express the opinion of an honest majority.</p></li>
</ul>
<p><em>Proof of Work</em> (<em>PoW</em>) is a consensus algorithm that achieves the above by
using hash functions. We previously talked about the fact that to get
a desired output there is no other solution than brute-force, trying random
inputs until one input generates a desired output. While brute-force
is often seen as a bad thing it does have some desirable properties:</p>
<ul class="simple">
<li><p>Given the parameters of the desired hash digest and a known amount of
computing power, it takes a predictable
amount of time to solve.</p></li>
<li><p>If it were a competition, the winner will most-likely be the one with
the greatest computing power.</p></li>
</ul>
<p>This means that brute-force hashing can limit the number of solutions
over a period of time and accurately describe the opinion of the majority.
In other words, it solves the two goals we want from a consensus algorithm!</p>
<p><em>Hash puzzle</em> is the desired output in PoW. The hash puzzle is a hash output
that is below a certain value, remember hash outputs are hexadecimal which
just represents a number. The value, known as the <em>target</em>, is calculated
through something known as the <em>difficulty</em> which roughly equates to
how difficult the hash puzzle is to solve. Blockchain’s typically adjust
the difficulty depending on how much computing power is present to
keep the ‘ABCT’, average block creation time, constant.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Bitcoin has an ‘ABCT’ of 10 minutes and readjusts its difficulty
every 2016 blocks, roughly 2 weeks. For the interested, the equations
for difficulty and the target are:</p>
<ul class="simple">
<li><p><strong>Difficulty</strong> = (Old Difficulty) * (Time taken for the last 2016
blocks to be produced)/(20160 minutes or 2 weeks) . Limited by
a factor of 4.</p></li>
<li><p><strong>Target</strong> = Difficulty Coefficient * 2^(8*((Difficulty Index)-2))</p></li>
</ul>
<p>Difficulty Coefficient - Last 3 bytes of the new difficulty.</p>
<p>Difficulty Index - First byte of the new difficulty.</p>
<p>Difficulty is 4 bytes long.</p>
</div>
<p>Difficulty is included in the block header along with a field called
the <em>nonce</em>. The <em>nonce</em> is a free field which can be populated with
anything and is meant to make the block header smaller than the target.</p>
<p><em>PoW</em> defines the valid chain as the one with the most cumulative
difficulty. As we assume an honest majority, the honest chain will
have the most blocks produced and so the greatest cumulative difficulty.
Even if a dishonest attacker manages to create a new block, statistically
the honest majority will always overtake the malicious chain given enough
time.</p>
<p><em>PoW</em> works on the process that once every node creates its candidate
block it will modify the nonce until the hash of the block header is below
the target. This is difficult to achieve but very easy to verify, you
just evaluate: <em>target</em> &gt; <em>block header</em>.</p>
<p><em>PoW</em> also has the consequence
that the definition of an honest majority is a majority of computing
power, even if the number of actual nodes is in the minority.</p>
</div>
</div>
<div class="section" id="public-private-cryptography">
<h2><span class="section-number">2.1.3. </span>Public-Private Cryptography<a class="headerlink" href="#public-private-cryptography" title="Permalink to this headline">¶</a></h2>
<p>We now know how to verify what data is in a block and
how to verify the block. What we are missing is how to verify the actual
data that goes into the block. This is a very general question that
largely depends on what <em>type</em> of data the blockchain is storing but
nearly every type of data needs to verify its source. While at first
sight this might seem irrelevant, it becomes important when a piece of
data orders the blockchain to move money from one account to another.</p>
<p>But how do we do this? Verifying the creator/origin of a piece
of data is very difficult as we can’t just give a handwritten signature like
we can in the real-world. The solution lies in a topic called
<em>Public-Private Cryptography</em>.</p>
<p><strong>Public-Private Cryptography</strong> (<em>PPC</em>) is a set of cryptographic algorithms that
work on the basis of two keys, a <em>public key</em> and <em>private key</em>. These
two keys are mathematically linked in such a way that anything <em>encrypted</em>
with the private key can only be decrypted with its corresponding public key
and only that public key. The private key is kept private and should not be shared with anyone
while the public key can and should be shared with everyone.</p>
<p><em>PPC</em> is a very important subset of cryptography and is used extensively
in real-world applications. <em>PPC</em> provides two key benefits that
make it useful:</p>
<ul class="simple">
<li><p>It can be used to verify that a certain digital entity, represented
by a public key, attested to some piece of data, by encrypting it with
their private key.</p></li>
<li><p>They allow for peer-to-peer secret communication. This is because each side can encrypt
their messages with the others public key which can only be decrypted with
the other party’s private key. Some PPC algorithms allow for public keys to encrypt and
private keys to decrypt.</p></li>
</ul>
<p>Blockchain is primarily interested in the first type of application
because it can be used in verifying the source of piece of data, a <em>digital signature</em>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This textbook uses the phrase data signature and digital signature,
but they are not interchangeable! Data signature refers to a hash, a unique
identifier of a piece of data anyone can calculate while digital signatures
are attestations by a public key that can only be signed by the possessor
of the corresponding private key.</p>
</div>
<div class="section" id="digital-signature">
<h3><span class="section-number">2.1.3.1. </span>Digital Signature<a class="headerlink" href="#digital-signature" title="Permalink to this headline">¶</a></h3>
<p>Formally <strong>digital signatures</strong> are a mathematical method to authenticate
the source of a message. They often incorporate the hash of the message
they are trying to authenticate in the signature. Digital signatures are meant to
be verifiable by anyone but can only be generated by one entity.
This is done by the one source or ‘verifier’ encrypting the message/data
with their private key and then anyone with their public key, which
should be publicly available, and the messages hash can verify their message/data signature.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Digital signatures boil down to proving one has the private key without
actually revealing the private key.</p>
</div>
<p>Digital signatures can work with just public and private keys but for
a number of reasons, one being they are shorter, participants on
the blockchain are identified not by their public key but by their
<em>address</em>.</p>
<p><strong>Address</strong> is the public key after a couple rounds of hashing and
being encoded into a more human-readable format, i.e. Base58 which
is shorter and can detect if you make an error writing it. Addresses
are smaller than the <em>raw</em> public key and are the most supported method
for identifying yourself on most blockchain projects.</p>
<div class="tip admonition">
<p class="admonition-title">Example</p>
<p>In the first chapter we looked at an example with a blockchain tracking how much
blocks each participant had. There we just assumed that the data about trading lego
was valid, but now we will analyze how we can guarantee that.
We are back on the lego blockchain and the current version of the
blockchain says you have 3 legos. Let’s say you want to give one of those
legos to Alice:</p>
<ol class="simple">
<li><p>You first write up the transaction that states you are transferring
1 lego to Alice.</p></li>
<li><p>You sign the transaction with your private key and broadcast the
signed transaction.</p></li>
<li><p>Other nodes pick the transaction up and through your address are
able to verify you did in fact agree to the lego transfer and considering
you have 3 legos the transaction is inductively correct.</p></li>
<li><p>The transaction is included in the latest block, and you are
down to 2 legos and Alice has one more.</p></li>
</ol>
</div>
</div>
<div class="section" id="ppc-implementations">
<h3><span class="section-number">2.1.3.2. </span>PPC Implementations<a class="headerlink" href="#ppc-implementations" title="Permalink to this headline">¶</a></h3>
<p>Like with hashing algorithms, there is no perfect <em>PPC</em> implementation
with each having pros and cons. We will be looking at two major
implementations: RSA and ECDSA.</p>
<div class="section" id="rsa">
<h4><span class="section-number">2.1.3.2.1. </span>RSA<a class="headerlink" href="#rsa" title="Permalink to this headline">¶</a></h4>
<p><strong>RSA</strong>, the name is derived form its creators’ initials, was developed in the 1970s and is a <em>PPC</em> algorithm that
is ‘double-sided’. By this we mean that you can take either public
or private key, encrypt a message and that message can only be
decrypted with the other key.</p>
<p>RSA works on the set of real numbers, this will be important later, and
heavily relies on the concept of <a class="reference external" href="https://www.computerhope.com/jargon/m/modulo.htm#:~:text=Modulo%20is%20a%20math%20operation,and%20r%20is%20the%20remainder.">modulo</a>
, which guarantees you can’t deduce the private key from the public key
and an encrypted message. Its public key is composed of two numbers while the private key
is composed of one number. All three numbers are derived from two very
large and random prime numbers that have
to be kept private as well.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>While RSA encryption is ‘double-sided’ you cannot interchange which key is private and which is
public. This is because the public key, composed of two numbers, is generated from the private
key. If you use the private key as the public key someone could easily generate the public
key you are keeping secret.</p>
</div>
<p>RSA is used heavily in industry as it is secure and easy to use.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>RSA is one of the more ‘straightforward’ encryption algorithms to
understand and for those interested it is one of the topics covered
by Cornell’s <a class="reference external" href="https://cornellcswiki.gitlab.io/classes/CS2800.html">CS2800</a></p>
</div>
</div>
<div class="section" id="ecdsa">
<h4><span class="section-number">2.1.3.2.2. </span>ECDSA<a class="headerlink" href="#ecdsa" title="Permalink to this headline">¶</a></h4>
<p>ECDSA, which stands for <em>Elliptical Curve Digital Signature Algorithm</em>,
is a <em>PPC</em> algorithm that is ‘single-sided’, you can only encrypt with
the private key and decrypt with the public key. ECDSA is <em>very</em> difficult
to crack but this is balanced out by the fact that you cannot use it in
p2p messaging like you can with RSA. This is because everyone can
decrypt a ECDSA-encrypted message, that is very much the point of ECDSA but
not very helpful when you are trying to send secret messages.</p>
<p>ECDSA’s power comes from the fact that unlike RSA, it does not work
on the set of real numbers but on a group on the prime order. This means
that it only works with a certain set of prime numbers. These prime numbers are points on a
plane that
form the path of an elliptical curve. All you need to know about this
elliptical curve is that it is symmetric along the x-axis, and it is
defined by an equation.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p><em>Groups</em> are a topic in complex mathematics. Forget about 1,2,3,4,…
groups work with only select numbers, often incomprehensibly complicated
or long.</p>
</div>
<p>One of the implications of ECDSA working on a group is that its operators, like
addition or multiplication, are not like the addition and
multiplication we are used to. While there are many operators, for
our needs we only need to know one, addition. This is because from
addition we can get multiplication, which is just addition <em>n</em> many
times, and multiplication is key in ECDSA.</p>
<div class="admonition-ecdsa-addition admonition">
<p class="admonition-title">ECDSA Addition</p>
<p>ECDSA is not easy to comprehend, and we do not expect you to understand it
fully here. Like with hashing we are only putting it here, so you can
gain an appreciation for the complexity that goes into the blockchain.</p>
<p>ECDSA is a group so addition means adding two points and getting another
point. To further simplify the example, and because we are primarily concerned
with multiplication, lets look at the addition of a single point to itself.</p>
<p><em>k+k</em>: You take the tangent at point k and find the other point the tangent
intersects the elliptical curve. Then flip that point along the x-axis, and
you have the result of k+k.</p>
<p>This is very easily done one way but given a point it is almost impossible
to find the two values that add up to it, the only strategy is brute-force
which is very ineffective.</p>
</div>
<p>ECDSA starts with a single point on the elliptical point known as
the <em>generator point</em>. This point is public and the same for everyone.
It then generates a random very large number that becomes the private key.
The equation for the public key is then:</p>
<p>Public Key = Private Key * Generator Point</p>
<p>The public key is then used along with the private key, the hash of the
message to be signed and a random number known as k to generate a digital
signature. This signature can be verified provided you have the
message, public key and the random number.</p>
<p>Another benefit of ECDSA is that because the elliptical curve is symmetric
along the x-axis we can denote the public key, which is just another
point on the curve, just through its x-coordinate and the sign of the
y-coordinate rather than the full coordinate. This cuts the size of the
public key by nearly half and this version is called the <em>compressed</em> public
key compared to the larger <em>uncompressed</em> public key.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Compressed public keys are so small that they are even smaller than addresses.
This raises the question of why we use addresses at all? The
reason is Bitcoin uses addresses and as the original blockchain project
we adopted alot of its features.</p>
<p>But why does Bitcoin use addresses? Well, there is <em>suspicion</em> that its
creator was unaware of compressed public keys and thats why Bitcoin
uses addresses.</p>
</div>
</div>
<div class="section" id="ecdsa-v-rsa">
<h4><span class="section-number">2.1.3.2.3. </span>ECDSA v RSA<a class="headerlink" href="#ecdsa-v-rsa" title="Permalink to this headline">¶</a></h4>
<p>RSA is an <em>encryption</em> algorithm while ECDSA is just a digital signature
algorithm. At first glance it might seem like RSA is the more practical of
the two and while it does have more use-cases both algorithms have their
benefits and drawbacks.</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>Algorithm</p></th>
<th class="head"><p>Pros</p></th>
<th class="head"><p>Cons</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>RSA</p></td>
<td><p>Can be used for both applications of PPC</p></td>
<td><p>More memory-intensive to store and process</p></td>
</tr>
<tr class="row-odd"><td><p>ECDSA</p></td>
<td><p>More space-efficient when it comes to storage &amp; processing</p></td>
<td><p>Is only a digital encryption algorithm, it can’t be used in p2p encryption</p></td>
</tr>
</tbody>
</table>
<p>The space efficiency was the deciding factor for why ECDSA is used in blockchain
projects like Bitcoin and Ethereum. When you require every participant
to store the whole blockchain a couple more bytes for every piece of data
starts to really add up.</p>
</div>
</div>
</div>
<div class="section" id="cryptography-in-action">
<h2><span class="section-number">2.1.4. </span>Cryptography in Action<a class="headerlink" href="#cryptography-in-action" title="Permalink to this headline">¶</a></h2>
<p>When describing RSA and ECDSA we used the word <em>random</em> alot. This is
incredibly important because the security of both RSA and ECDSA
is dependent on being as random as
possible. This introduces us to a common problem in cryptography: achieving <em>true random</em>.</p>
<p><strong>True random</strong> is something that is incredibly difficult to achieve
for computers because they only do exactly as they’re told. This makes generating
<em>randomness</em> very difficult because how do you tell a computer, in
exact detail, how to return a completely random number? The answer
is you can’t. Random functions in most computers aren’t
random at all but rather <em>pseudorandom</em> which are derived from mathematical
equations. This means they predictably create numbers given a starting
number called a <em>seed</em>. While this is ok for picking colors or the name of your
rock band it isn’t good in cryptography because attackers can predict
these numbers.</p>
<p>We began our discussion of digital signatures with the observation
that they are trying to prove you have the private
key without actually showing the private key. With possibly
thousands of such unique proofs, as different messages need to be
verified, it becomes increasingly difficult to keep the private key
private. This is where randomness comes in as with a constantly changing random
number added in to your digital signature your private key is hidden.
If you are only
putting pseudo-random numbers in, then the attacker can predict them and then
uncover your private key.</p>
<p>Randomness therefore underpins the security of cryptography. You might
be wondering how true random is achieved and the solution is
the physical world. Some random programs measure the exact heat of the cpu,
the background noise or even tell you to move your mouse around.
Computers become random by moving the task of randomness, or <em>entropy</em>, onto the physical
world which, for the most part, can be very random.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Those who neglected randomness in cryptography are often punished for it.
A good example is Sony which used ECDSA for verification in its PS3 store.
While this might seem like a responsible thing to do, Sony didn’t use
random numbers at all, it just used one number for all of its digital
signatures.</p>
<p>The result was that the private key was almost immediately revealed
and the PS3 store was hacked.</p>
</div>
<div class="section" id="cryptography-in-the-blockchain">
<h3><span class="section-number">2.1.4.1. </span>Cryptography in the Blockchain<a class="headerlink" href="#cryptography-in-the-blockchain" title="Permalink to this headline">¶</a></h3>
<p>In this chapter we covered hashing and PPC. Their use cases in blockchain
are:</p>
<ul class="simple">
<li><p>Hashing is the backbone of the Merkle Tree data structure that blocks
use to store their data.</p></li>
<li><p>In PoW, hashing is also used as the solution to block validation and
consensus through the hash puzzle.</p></li>
<li><p>ECDSA cryptography validates individual pieces of data in a blockchain
as it allows anyone to definitely prove the source of or attestation to, a
piece of data in the blockchain.</p></li>
</ul>
<p>A common format of data in the blockchain are transactions which depend
on cryptography even more. This because a standard transaction is
composed of:</p>
<ul class="simple">
<li><p>Sender &amp; Receiver - Often identified through their addresses/public keys</p></li>
<li><p>Transaction Amount - Standard Number (No cryptography involved)</p></li>
<li><p>Signature of Sender - An ECDSA proof of the sender’s consent to move
the amount listed.</p></li>
</ul>
<p>You may have noticed that no where in the blockchain transaction did
we mention the personal details of the sender or receiver, only their
cryptographic keys. This is called <em>pseudonymity</em>.</p>
<p><strong>Pseudonymity</strong> is when a party is only reachable through its
cryptographic identity which is disconnected from its physical one.
There is a gap between the physical and the cryptographic, but it is
a gap that can, and sometime has, been bridged.</p>
<p>Being pseudonymous does not
imply anonymity. A public key’s interactions are public-knowledge and interacting with well
known public keys, like those of a bank or public exchange, can be
used along with physical tracking devices, like security cameras, to deduce the
actual identity behind the public key.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>On most blockchain implementations the participants are pseudonymous, not
anonymous.</p>
</div>
</div>
<div class="section" id="back-to-byzantium">
<h3><span class="section-number">2.1.4.2. </span>Back to Byzantium<a class="headerlink" href="#back-to-byzantium" title="Permalink to this headline">¶</a></h3>
<p>Coming back to the Byzantine General’s problem, this chapter helped the generals verify that messages originate
from other generals and are not forged by unreliable messengers.
This guarantees communication between generals is un-tamper-able as
a modified message would have a different hash which would not fit
into the provided digital signature, which cannot be forged because
Byzantium nor the messengers have the private key.</p>
<p>We have also started exploring one possible solution for the generals
achieving consensus, agreeing on the exact content of the valid chain,
through PoW.</p>
<p>The generals now have a message format, the blockchain, that is
trustworthy if there is an honest majority and it will now only
contain data that verifiably originates from the generals and not
some malicious third party. However, we are still lacking coordination,
how the generals organize this whole blockchain. This will be
the topic of out next chapter, <em>networks</em>.</p>
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./chapters\crypto"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
            <!-- Previous / next buttons -->
<div class='prev-next-area'> 
    <a class='left-prev' id="prev-link" href="title.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title"><span class="section-number">2. </span>Cryptography</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="summary.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">2.2. </span>Summary</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
        
        </div>
    </div>
    <footer class="footer">
    <div class="container">
      <p>
        
          By Daniel Mistrik & Cornell Blockchain<br/>
        
            &copy; Copyright 2022.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>
  
  <script src="../../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>